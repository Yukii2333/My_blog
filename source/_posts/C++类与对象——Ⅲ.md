---
title: C++类与对象——Ⅲ
date: 2023-05-12 20:42:18
categories: Notes
tags: 
 - C++
description: Note about Class of C++
cover:
---

## 补充

补充一点上一篇的东西

### const成员

**将const修饰的“成员函数称之为const成员函数”**，const成员修饰类成员函数，实际修饰该成员函数**隐含的this指针**，表明该成员函数中**不能对类的任何成员进行修改**。

如

~~~C++
//最开始写的日期类的打印函数	
//很显然函数内没有对*this进行任何修改操作
//因此在函数后加上了 const
void Print() const
{
	cout << year_ << "-" << month_ << "-" << day_ << endl;
}

//经编译器处理后，可以认为会变成这样
//第一个 const修饰 *this，是我们添加的
//第二个 const修饰 this，是类成员函数自带的
void Print(const Date* const this)
{
	cout << this->year_ << "-" << this->month_ << "-" << this->day_ << endl;
}
~~~

该方式的作用之一就是**使得 const对象能对一些不修改成员变量的成员函数进行使用（譬如日期类的打印、日期加减天数、日期减日期等）**



### 取地址及 const取地址操作符重载

这两个也是默认成员函数，一般不用重新定义，编译器也会默认生成

~~~C++
//this指针指向就是调用该函数的对象的地址
//因此返回this即可
Date* Date::operator&()
{
	return this;
}

//针对const Date* 对象的取地址
const Date* Date::operator&() const
{
	return this;
}
~~~

这两个运算符一般不需要重载，使用编译器生成的默认取地址的重载即可，只有特殊情况，才需要重载，比如想让别人获取到**指定的内容！**



# 类与对象 Ⅲ

## 深入构造函数

### 构造函数体赋值

在对象实例化时，编译器通过调用构造函数，给对象中每一个成员变量一个合适的初始值

~~~C++
class Date
{
public:
	Date(int year, int month, int day)
	{
		year_ = year;
		month_ = month;
		day_ = day;
	}

private:
	int year_;
	int month_;
	int day_;
};
~~~

虽然在调用上述构造函数只后，对象中已经有了一个初始值，但是不能将其称之为对对象成员变量的初始化，**构造函数体中的语句只能将其称为赋值初始化**。因为**初始化只有一次，而构造体内可以多次赋值（可以理解为初始化可以不传值，而上面的类实例化时的成员变量会是编译器生成的默认构造函数来进行初始化，对于内置类型大多数编译器不会进行处理）**。

### 初始化列表

以一个**冒号开始**，接着是一个以**逗号**分隔的**数据成员列表**，每个**成员变量**后面跟一个**放在括号中的初始值或表达式**。

~~~C++
class Date
{
public:
	Date(int year, int month, int day)
        : year_(year)
        , month_(month_)
        , day_(day)
	{}

private:
	int year_;
	int month_;
	int day_;
};
~~~

**注意**

1. 每个成员变量在初始化列表中**只能出现一次**（因为初始化只能进行一次）
2. 类中包含以下成员，必须在初始化列表位置进行初始化（因为下面的类型必须在定义时就初始化）：

* 引用成员变量
* const 成员变量
* 自定义类型成员（没有默认构造函数）

3. 初始化列表的初始化顺序是按照类中成员变量的声名顺序初始化，与初始化列表无关，因此建议初始化列表顺序与声名顺序一致

~~~C++
//声名顺序先是a_再是b_
class A
{
public:
    //初始化队列时，看似是先初始化a_
    //实际上是先初始化b_
    //但a_此时还未被初始化
    //因此调用后输出结果是
    //a_:1
	//b_:-858993460
	A(int a)
		:a_(a)
		,b_(a_)
	{

	}
	void Print()
	{
		cout << "a_:" << a_ << endl;
		cout << "b_:" << b_ << endl;
	}
private:
	int b_;
	int a_;
};

int main()
{
	A a(1);
	a.Print();
	return 0;
}
~~~

4. 尽量使用初始化列表初始化，因为不管是否使用初始化列表初始化，对于自定义成员变量，一定会用初始化列表初始化

~~~C++
class A
{
public:
    //A中写了初始化列表
    //调用时会打印一点内容
	A()
		:a_(0)
	{
		cout << "A()" << endl;
	}
private:
	int a_;
};

//类B中的成员变量有一个自定义类型和一个内置类型
class B
{
public:
    //B中没有写初始化列表
	B(int b)
	{}

private:
	A ba_;
	int bb_;
};

int main()
{
	B b;
	return 0;
}
//执行该代码后，在命令窗口内出现了“A()”的内容
//说明即便是不写初始化列表，实际上也会存在
//因为初始化列表是构造函数的一部分，不写依然会执行
~~~

### explicit关键字

构造体函数不仅可以构造与初始化对象，对于**单个参数或者除第一个参数无默认值其余均有默认值的构造函数**，还具有**类型转换**作用

~~~C++
//下面一段代码是能正常执行的
//最后打印结果为1
class A
{
public:
	A(int a)
		:a_(a)
	{}
	void Print()
	{
		cout << a_ << endl;
	}
private:
	int a_ = 0;
};


int main()
{
	A a1 = 1;
	a1.Print();
	return 0;
}
//其中 A a1 = 1 这里
//编译器会创建一个A的临时对象来存储 1，然后再用临时对象进行构造a1
//这就是类型转换


//当在构造函数前加上explicit后，禁用类型转换，使得 A a1 = 1不能进行
// error C2440: “初始化”: 无法从“int”转换为“A”
~~~

explicit能够禁用类型转换，作用是为了在一些情况下**禁止不规范的使用，增加代码可读性**

### static成员

#### 概念

声明为**static的类成员**称为**类的静态成员**，用**static修饰**的**成员变量**，称之为**静态成员变量**，则函数称之为**静态成员函数**。

**静态成员变量**一定要在**类外进行初始化**

~~~C++
class A
{
public:
	void Print()
	{
		cout << a_ << endl;
	}
private:
    //静态成员变量a_
	static int a_;
};

//在类外进行 初始化/定义
int A::a_ = 0;

int main()
{
	A a1;
	a1.Print();
	return 0;
}
~~~

#### 特性

* **静态成员**为**类对象共享**，不属于具体某一个类，存放在静态区
* **静态成员变量**必须在**类外定义**，定义时不添加 static，类中只是声明，**生命周期是全局**，类型 类名::变量名 = xxx;
* 类静态成员既可以用 **类名::静态成员来访问**，也可以用 **对象.静态成员**来访问（静态成员变量可以被private修饰来阻止直接访问）
* 静态成员函数**没有**隐藏的**this指针**，不能访问任何**受限的非静态成员**
* 静态成员也是类的成员，同样受public、protected、private 访问限定的限制

### 友元

#### 友元函数

之前在日期类的实现时用到过，重载operator<<时，发现如果将其重载为成员函数，**this指针会抢占第一个位置**，使得使用时对象和cout的位置是反过来的，operator>>也同理，所以其都重载成了全局函数，但是全局函数又不能直接访问类的成员变量，若改成public，则类的封装性又会降低，而当时就用到了友元。



**友元函数**可以**直接访问**类的**私有**成员，它是**定义在类外**的**普通函数**，不属于任何类，但需要在类的内部声明，声明时在前面加上**friend**关键字。

~~~C++
class Date
{
	//友元函数声名
	friend std::ostream& operator<<(std::ostream& out, const Date& d);
	friend std::istream& operator>>(std::istream& in, Date& d);
public:
    //...
private:
	int year_;
	int month_;
	int day_;
};

//重载流提取
ostream& operator<<(ostream& out, const Date& d);

//重载流插入
istream& operator>>(istream& in, Date& d);

//虽然要在类内部声明
//但是函数在外部的声明依然不能省略
~~~

* **友元函数**可以访问类的私有和保护成员，但是**不是类的成员函数**
* 友元函数**不能用const修饰**
* **友元函数**可以在类定义的任何一行声明，**不受类访问限定符限制**

* 一个函数可以是多个类的友元函数
* 友元函数的调用与普通函数的调用原理相同

#### 友元类

友元类的所有成员函数都可以是另一个类的友元函数，都可以访问类一个类中的非公有成员。

~~~C++
//类A与类B是两个不同的类
class B
{
public:
	void Print(const A& a)
	{
		cout << "a_:" << a.a_ << endl;
		cout << "b_:" << b_ << endl;
	}
private:
	int b_;
};

class A
{
    //在类A内部任意位置进行友元声明
    //与友元函数一致
	friend class B;
public:
	//...
private:
	int a_;
};
~~~

**注意**

* 友元是单向的，**不具有交换性**

​              如上述的类，B是A的友元类，B可以直接访问A的私有成员变量，但是反过来访问却不行，因为A并不是B的友元类，因此不能访问B的私有成员变量。

* 友元关系**不能传递**

​			   比如在B中还有一个内部类C，C就是B的友元类，而B又是A的友元类，但是，C并不是A的友元类

* 友元关系**不能继承**

​			   原因在后面学到继承会提到

#### 内部类

如下，如果**一个类定义在另一个类的内部，那定义在内部的类就叫做内部类**。内部类是一个独立的类，它不属于外部类，更不能通过外部类的对象去访问内部类的成员。

因此在用 sizeof() 计算对象大小时，内部类的成员变量是不会被算入的，就好比你买了一套房，然后送给你了一张跟你房子无关的房子图纸，图纸没有进行实例化，即便是实例化了也不会占用你的房子的空间。

**内部类是外部类的友元**，遵循的原则跟友元类一致

~~~C++
//类A
class A
{
    //类B
    //B定义在A内部
    //因而B天生就是A的友元类
	class B
	{
	public:
        //正因为B是A的友元类
        //B中能够直接访问A中的私有成员
        //但是在A中却不能访问B的私有成员
		void Print(const A& a)
		{
			cout << "a_:" << a.a_ << endl;
			cout << "b_:" << b_ << endl;
		}
	private:
		int b_;
	};

public:
	//...
private:
	int a_;
};
~~~

