---
title: C++二叉树进阶
date: 2023-10-01 14:28:09
categories: C++
tags:
 - C++
 - Binary Tree
 - Binary Search Tree
 - AVL Tree
description:
cover:
---

**最基本的二叉树已经在数据结构的学习中就已经了解了，因此主要介绍的是二叉树的进阶，即二叉搜索树。**

# 二叉搜索树的概念

**二叉搜索树也称二叉排序树，该树要么是空树**，要么满足如下特征：

* **若它的左子树不为空，则左子树上所有节点的值都小于根节点的值**
* **若它的右子树不为空，则右子树上所有节点的值都大于根节点的值**
* **它的左右子树也分别为二叉搜索树**

*二叉搜索树的中序遍历是有序的（升序）*

# 二叉搜索树的操作

对`a[8]={8,7,10,5,4,6,9,11}`建立一颗二叉搜索树就如下图：

![二叉搜索树](https://raw.githubusercontent.com/Yukii2333/Images/main/blog_image/202310011442666.png "二叉搜索树")

## 二叉搜索树的搜索

* 从根开始比较，传入值大于根节点就往右树找，小于则往左树找。
* 最多查找高度次，走到空还未找到说明该值不存在。

## 二叉搜索树的插入

* 树为空，则创建一个新节点，插入值作为根。
* 树不为空，先类似于查找的方式，经过比较找到合适的位置。

![插入](https://raw.githubusercontent.com/Yukii2333/Images/main/blog_image/202310011500331.png "插入")

## 二叉搜索树的删除

**首先查找元素是否在二叉搜索树中，如果不存在，则返回false, 否则要删除的结点可能分下面四种情：**

1. 要删除的结点无子结点
2. 要删除的结点只有左结点
3. 要删除的结点只有右结点
4. 要删除的结点左右结点都有

看似有四种情况，世界上只有三种，即无子结点、一个子结点以及两个子结点。

* 对于无子结点直接删除即可。
* 一个子结点的情况，先记录子结点，然后删除目标节点，父节点原本指向目标节点的位置指向子结点
  * 由于实际操作的情况下还是要分成两类来写，但第一种可以随便归类到这两种的其中一种当中（由于本身就要进行置空）

* 对于目标节点有两个子结点的情况，有两种解决方法：
  * 选取左树中的最右结点（最大结点）来替代目标节点的位置
  * 选取右树中的最左结点（最小结点）来替代目标节点的位置

# 二叉搜索树的实现以及应用

## 二叉搜索树的实现

二叉搜索树的实现代码：[Github链接](https://github.com/Yukii2333/Daily-Code/blob/main/Works/Work_cpp/2023_08_01_BSTree/BSTree.h)

## 二叉搜索树的应用

* **K模型，即只有key作为关键码，结构中只需要存储Key即可，关键码即为需要搜索到的值。**比如：给一个单词word，判断该单词是否拼写正确，具体方式如下：
  * 以词库中所有单词集合中的每个单词作为key，构建一棵二叉搜索树
  * 在二叉搜索树中检索该单词是否存在，存在则拼写正确，不存在则拼写错误

* **K&V模型，每一个关键码key，都有与之对应的值Value，即<key,value>的键值对**。其在生活中很常见，如：
  * **英汉词典就是英文与中文的对应关系**，通过英文可以快速找到与其对应的中文，英文单词与其对应的中文就构成一种键值对；
  * **统计单词次数**，统计成功后，给定单词就可快速找到其出现的次数，**单词与其出现次数就是<word,count>**就构成一种键值对。

*显然两种模型所使用的结构有一点差异，就目前来说，直接再写一个新的就行了，后续会有解决方法*

# 二叉搜索树的性能分析

插入和删除操作都必须先查找，**查找效率代表了二叉搜索树中各个操作的性能**。

对有n个结点的二叉搜索树，若每个元素查找的概率相等，则二叉搜索树平均查找长度是结点在二叉搜索树的深度的函数，即结点越深，则比较次数越多。

但对于同一个关键码集合，如果各关键码插入的次序不同，可能得到不同结构的二叉搜索树：

![二叉搜索树](https://raw.githubusercontent.com/Yukii2333/Images/main/blog_image/202310011524181.png "二叉搜索树")



**最优情况下，二叉搜索树为完全二叉树(或者接近完全二叉树)，其平均比较次数为：`log(2N)`,最差情况下，二叉搜索树退化为单支树(或者类似单支)，其平均比较次数为：\frac{N}{2}（介于N与log(2N)之间）**











